<!DOCTYPE html>
<html>
<head>
    <title>Endless runner - Game Page</title>
    <meta content="width=device-width, initial-scale=1" name="viewport">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.130.1/examples/js/loaders/GLTFLoader.js"></script>
    <style>
        body {
            margin: 0;
        }
        #timer {
            position: absolute;
            top: 20px;
            left: 20px;
            font-family: Arial, sans-serif;
            font-size: 24px;
            color: white;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }
    </style>
</head>
<body class="body" style="overflow: hidden;">
    <div id="timer"></div>
    <script>
        var gameStarted = false;
        var startTime;
        var timerElement = document.getElementById('timer');
        var character; // Define character object globally

        var Colors = {
            roadColor: 0x999999,
            obstacleColor: 0xff0000,
            characterColor: 0x00ff00,
            ballColor: 0x8B4513
        };

        window.addEventListener('load', function(){
            startGame();
        });

        function startGame() {
            gameStarted = true;
            startTime = Date.now();
            new World();
        }

        function endGame() {
            gameStarted = false;
            var currentTime = Date.now();
            var elapsedTime = Math.floor((currentTime - startTime) / 1000);
            sessionStorage.setItem('elapsedTime', elapsedTime); // Save elapsed time in sessionStorage
            window.location.href = 'end.html'; // Redirect to end.html to show the end page
        }

        function World() {
            'use strict';
            var scene, camera, renderer, road, obstacles = [];
            var container, aspectRatio,
                HEIGHT, WIDTH, fieldOfView,
                nearPlane, farPlane,
                mouseX, mouseY, windowHalfX,
                windowHalfY, geometry,
                starStuff, materialOptions,starField;

            this.speed = 10;    

            init();


            function init() {
                container = document.createElement('div');
                document.body.appendChild(container);
                document.body.style.overflow = 'hidden';

                HEIGHT = window.innerHeight;
                WIDTH = window.innerWidth;
                aspectRatio = WIDTH / HEIGHT;
                fieldOfView = 75;
                nearPlane = 1;
                farPlane = 1000;
                mouseX = 0;
                mouseY = 0;

                windowHalfX = WIDTH / 2;
                windowHalfY = HEIGHT / 2;

                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
                camera.position.set(0, 500, -1000);
                camera.lookAt(0, 50, 0);

                scene = new THREE.Scene();
                scene.fog = new THREE.FogExp2(0x000000, 0.0003);

                var ambientLight = new THREE.AmbientLight(0xffffff, 10);
                scene.add(ambientLight);

                character = null;

                var loader = new THREE.GLTFLoader();
                loader.load('nave_espacial/scene.gltf', function (gltf) {
                    character = gltf.scene;
                    character.scale.set(10, 10, 10);
                    character.position.x = Math.random() * 1000 - 200;
                    character.position.y = 100;
                    scene.add(character);
                });

                renderer = new THREE.WebGLRenderer();
                renderer.setClearColor(0x000011, 1);
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.setSize(WIDTH, HEIGHT);
                document.body.appendChild(renderer.domElement);

                createStars();

                const numObstacles = Math.floor(Math.random() * 5) + 1; // Random number between 1 and 5
                for (let i = 0; i < numObstacles; i++) {
                    createObstacle(scene);
                }

                window.addEventListener('resize', onWindowResize, false);
                loop();
            }


            function createObstacle(scene) {
                var loader = new THREE.GLTFLoader();
                loader.load('asteroid/scene.gltf', function (gltf) {
                    var obstacle = gltf.scene;
                    obstacle.scale.set(100, 100, 100);
                    obstacle.position.x = Math.random() * 900 - 200;
                    obstacle.position.y = 25;
                    obstacle.position.z = 1000;
                    scene.add(obstacle);
                    obstacles.push(obstacle);
                    if (obstacles.length > 4) {
                        scene.remove(obstacles.shift());
                    }
                });
            }


            const moveLeft = () => {
                if (character && character.position.x < 900) {//mudar até onde a nave vai
                    character.position.x += this.speed;
                }
            };

            const moveRight = () => {
                if (character && character.position.x > -900) {//mudar até onde a nave vai
                    character.position.x -= this.speed;
                }
            };

            const jump = () => {
                if (character && character.position.y === 25) {
                    character.position.y += 300;
                    setTimeout(() => {
                        character.position.y -= 300;
                    }, 500);
                }
            };

            document.addEventListener('keydown', function (event) {
                console.log('Key pressed:', event.key);
                console.log('Character:', character);
                if (gameStarted) {
                    if (event.key === 'ArrowLeft') {
                        moveLeft();
                    } else if (event.key === 'ArrowRight') {
                        moveRight();
                    } else if (event.key === 'ArrowUp') {
                        jump();
                    }
                }   
            });

            function createStars(){
                var stars = new Array(0);
                for ( var i = 0; i < 10000; i ++ ) {
                    let x = THREE.Math.randFloatSpread( 2000 );
                    let y = THREE.Math.randFloatSpread( 2000 );
                    let z = THREE.Math.randFloatSpread( 2000 );
                    stars.push(x, y, z);
                }
                var starsGeometry = new THREE.BufferGeometry();
                starsGeometry.setAttribute(
                    "position", new THREE.Float32BufferAttribute(stars, 3)
                );
                var starsMaterial = new THREE.PointsMaterial( { color: 0x888888 } );
                starField = new THREE.Points( starsGeometry, starsMaterial );
                scene.add( starField );
            }

            function onWindowResize() {
                var WIDTH = window.innerWidth,
                    HEIGHT = window.innerHeight;

                camera.aspect = aspectRatio;
                camera.updateProjectionMatrix();
                renderer.setSize(WIDTH, HEIGHT);
            }

            function loop() {
                starField.rotation.x += 0.001;
                starField.rotation.y += 0.001;

                for (var i = 0; i < obstacles.length; i++) {
                    var obstacle = obstacles[i];
                    if (obstacle.position) {
                        obstacle.position.z -= 10;
                        if (obstacle.position.z < -1000) {
                            obstacle.position.z = 1050;
                            obstacle.position.x = Math.random() * 400 - 200;
                        }
                        if (character){
                            if (character.position.distanceTo(obstacle.position) < 350) { // Adjust 100 to the appropriate collision distance
                                endGame();
                                return; // Stop the loop if the game is over
                            }
                        }
                    }
                }

                if (gameStarted) {
                    var currentTime = Date.now();
                    var elapsedTime = Math.floor((currentTime - startTime) / 1000);
                    timerElement.textContent = 'Time: ' + elapsedTime + 's';
                }

                renderer.render(scene, camera);
                requestAnimationFrame(loop);
            }
            loop();
        };
    </script>
</body>
</html>



