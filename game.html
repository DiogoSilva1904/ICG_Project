<!DOCTYPE html>
<html>
<head>
    <title>Endless runner - Game Page</title>
    <meta content="width=device-width, initial-scale=1" name="viewport">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.130.1/examples/js/loaders/GLTFLoader.js"></script>
    <style>
        body {
            margin: 0;
        }
        #timer {
            position: absolute;
            top: 20px;
            left: 20px;
            font-family: Arial, sans-serif;
            font-size: 24px;
            color: white;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }
        #powerup-bar {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 20px;
            background-color: #ccc;
            border: 1px solid #999;
        }
        #powerup-progress {
            height: 100%;
            background-color: lightblue;
            transition: width 0.5s ease;
        }
        #shield-text {
            position: absolute;
            bottom: 50px;
            right: 20px;
            font-family: Arial, sans-serif;
            font-size: 18px;
            color: white;
            display: none; /* Initially hidden */
        }
    </style>
</head>
<body class="body" style="overflow: hidden;">
    <div id="timer"></div>
    <div id="powerup-bar">
        <div id="powerup-progress"></div>
    </div>
    <div id="shield-text">Shield Available</div>
    <script>
        var gameStarted = false;
        var startTime;
        var timerElement = document.getElementById('timer');
        var character; // Define character object globally
        var lastPowerUpSpawnTime = Date.now(); // Initialize last power-up spawn time
        var powerUpSpawnInterval = 10000;
        var powerUpCollected = false; // Flag to indicate whether the power-up is collected
        var shotTimeout;
        var alien;
        var astronaut;
        var satelite;
        var lastSpeedIncrease = 0;
        var obstacleSpeed=10 ; // Speed of the obstacles
        var activateShields = false;

        var Colors = {
            roadColor: 0x999999,
            obstacleColor: 0xff0000,
            characterColor: 0x00ff00,
            ballColor: 0x8B4513
        };

        window.addEventListener('load', function() {
            startGame();
        });

        function startGame() {
            gameStarted = true;
            startTime = Date.now();
            new World();
        }

        function endGame() {
            gameStarted = false;
            var currentTime = Date.now();
            var elapsedTime = Math.floor((currentTime - startTime) / 1000);
            sessionStorage.setItem('elapsedTime', elapsedTime); // Save elapsed time in sessionStorage
            window.location.href = 'end.html'; // Redirect to end.html to show the end page
        }

        function World() {
            'use strict';
            var scene, camera, renderer, road, obstacles = [],
                powerUps = [];
            var container, aspectRatio,
                HEIGHT, WIDTH, fieldOfView,
                nearPlane, farPlane,
                mouseX, mouseY, windowHalfX,
                windowHalfY, geometry,
                starStuff, materialOptions, starField;
            var collectedPowerUps = 0;      


            this.speed = 10;

            init();

            function init() {
                container = document.createElement('div');
                document.body.appendChild(container);
                document.body.style.overflow = 'hidden';

                HEIGHT = window.innerHeight;
                WIDTH = window.innerWidth;
                aspectRatio = WIDTH / HEIGHT;
                fieldOfView = 75;
                nearPlane = 1;
                farPlane = 1000;
                mouseX = 0;
                mouseY = 0;

                windowHalfX = WIDTH / 2;
                windowHalfY = HEIGHT / 2;

                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
                camera.position.set(0, 500, -1000);
                camera.lookAt(0, 50, 0);

                scene = new THREE.Scene();
                scene.fog = new THREE.FogExp2(0x000000, 0.0003);

                var ambientLight = new THREE.AmbientLight(0xffffff, 10);
                scene.add(ambientLight);

                character = null;
                satelite = null;
                alien = null;
                astronaut = null;

                var loader = new THREE.GLTFLoader();
                loader.load('elemental_water_spaceship_small/scene.gltf', function(gltf) {
                    character = gltf.scene;
                    character.scale.set(10, 10, 10);
                    character.position.x = Math.random() * 1000 - 200;
                    character.position.y = 100;
                    character.position.z = -500;
                    scene.add(character);
                });


                loader.load('alien_ship_low_poly/scene.gltf',function(gltf){
                    alien = gltf.scene;
                    alien.scale.set(100, 100, 100);
                    alien.position.z = 0;
                    alien.position.x = 1400;
                    alien.position.y = 200;
                    scene.add(alien);
                });

                loader.load('star_wars_battlefront_-_tie_fighter/scene.gltf', function(gltf) {
                    astronaut = gltf.scene;
                    astronaut.scale.set(30, 30, 30);
                    astronaut.position.z = 500;
                    astronaut.position.x = 3000;
                    astronaut.position.y = 500;
                    astronaut.rotation.y = Math.PI / 2;
                    scene.add(astronaut);
                });

                renderer = new THREE.WebGLRenderer();
                renderer.setClearColor(0x000011, 1);
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.setSize(WIDTH, HEIGHT);
                document.body.appendChild(renderer.domElement);

                createStars();

                const ROOM_WIDTH = WIDTH; // Example room width
                const ROOM_HEIGHT = HEIGHT; // Example room height
                const ROOM_DEPTH = 1000; // Example room depth

                const skyboxGeo = new THREE.BoxGeometry(ROOM_WIDTH * 2 + 10, ROOM_HEIGHT * 2 + 10, ROOM_DEPTH * 2 + 10);

                const materialArray = [
                    new THREE.MeshBasicMaterial({
                        map: new THREE.TextureLoader().load("purplenebula/purplenebula_ft.png"),
                        side: THREE.DoubleSide,
                    }),
                    new THREE.MeshBasicMaterial({
                        map: new THREE.TextureLoader().load("purplenebula/purplenebula_bk.png"),
                        side: THREE.DoubleSide,
                    }),
                    new THREE.MeshBasicMaterial({
                        map: new THREE.TextureLoader().load("purplenebula/purplenebula_up.png"),
                        side: THREE.DoubleSide,
                    }),
                    new THREE.MeshBasicMaterial({
                        map: new THREE.TextureLoader().load("purplenebula/purplenebula_dn.png"),
                        side: THREE.DoubleSide,
                    }),
                    new THREE.MeshBasicMaterial({
                        map: new THREE.TextureLoader().load("purplenebula/purplenebula_rt.png"),
                        side: THREE.DoubleSide,
                    }),
                    new THREE.MeshBasicMaterial({
                        map: new THREE.TextureLoader().load("purplenebula/purplenebula_lf.png"),
                        side: THREE.DoubleSide,
                    }),
                ];

                const skybox = new THREE.Mesh(skyboxGeo, materialArray);
                scene.add(skybox);

                const numObstacles = 4; // Fixed number of obstacles
                for (let i = 0; i < numObstacles; i++) {
                    createObject(scene, obstacles);
                }

                window.addEventListener('resize', onWindowResize, false);
                loop();
            }

            var spawnPositions = [
                new THREE.Vector3(900, 100, 1000),  // Position 1
                new THREE.Vector3(300, 100, 1500),  // Position 3
                new THREE.Vector3(400, 100, 1200),  // Position 4
                new THREE.Vector3(500, 100, 1000),  // Position 6
                new THREE.Vector3(600, 100, 1500),  // Position 7
                new THREE.Vector3(700, 100, 1900),  // Position 8
                new THREE.Vector3(800, 100, 1500),  // Position 9
                new THREE.Vector3(200, 100, 1000),  // Position 10
                new THREE.Vector3(0, 100, 1500),  // Position 11
                new THREE.Vector3(-100, 100, 1000),  // Position 20
                new THREE.Vector3(-200, 100, 1500),  // Position 21
                new THREE.Vector3(-300, 100, 1900),  // Position 22
                new THREE.Vector3(-400, 100, 1500),  // Position 23
                new THREE.Vector3(-500, 100, 1000),  // Position 24
                new THREE.Vector3(-600, 100, 1500),  // Position 25
                new THREE.Vector3(-700, 100, 1900),  // Position 26
                new THREE.Vector3(-800, 100, 1500),  // Position 27
                new THREE.Vector3(-900, 100, 1000),  // Position 28
                new THREE.Vector3(-1000, 100, 1500),  // Position 29
                new THREE.Vector3(-1100, 100, 1900),  // Position 30
            ];

            var chosenPositions = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,0,0,0];
            var nextSpawnPositionIndex = 0;

            function createObject(scene, objectList) {
                var loader = new THREE.GLTFLoader();
                var modelPaths = ['asteroid/scene.gltf', 'space_raw_material/scene.gltf']; // Array of model paths

                // Choose a random model path
                var randomModelIndex = Math.floor(Math.random() * modelPaths.length);
                var chosenModelPath = modelPaths[randomModelIndex];

                loader.load(chosenModelPath, function (gltf) {
                    var obstacle = gltf.scene;
                    if(chosenModelPath === 'space_raw_material/scene.gltf'){
                        obstacle.scale.set(40, 40, 40);
                    }
                    else{
                        obstacle.scale.set(100, 100, 100);
                    }
                    obstacle.scale.set(50, 50, 50);

                    var chosenPositionIndex = null;

                    // Create a random number in the range of 0 to 19
                    var random = Math.floor(Math.random() * 19);

                    // Find the next available position that hasn't been chosen before
                    for (var i = 0; i < spawnPositions.length; i++) {
                        var positionIndex = (nextSpawnPositionIndex + i) % spawnPositions.length;
                        if (chosenPositions[positionIndex] === 0) {
                            chosenPositionIndex = positionIndex;
                            chosenPositions[positionIndex] = 1; // Mark the position as chosen
                            nextSpawnPositionIndex = (positionIndex + 1) % spawnPositions.length; // Update next spawn position index
                            break;
                        }
                    }

                    // If all positions have been chosen, reset the chosen positions array
                    if (chosenPositionIndex === null) {
                        chosenPositions = Array(spawnPositions.length).fill(0);
                        nextSpawnPositionIndex = 0;
                        chosenPositionIndex = 0;
                    }

                    var chosenPosition = spawnPositions[chosenPositionIndex];
                    obstacle.position.copy(chosenPosition);
                    scene.add(obstacle);
                    objectList.push(obstacle);

                    // Remove excess obstacles
                    if (objectList.length > spawnPositions.length) {
                        var removedObstacle = objectList.shift();
                        scene.remove(removedObstacle);
                    }
                });
            }


            function createPowerUp(scene, powerUps) {
                var loader = new THREE.GLTFLoader();
                loader.load('jerry_can/scene.gltf', function(gltf) {
                    var powerUp = gltf.scene;
                    powerUp.scale.set(5, 5, 5);

                    var chosenPositionIndex = null;

                    var random = Math.floor(Math.random() * 19);

                    for (var i = 0; i < spawnPositions.length; i++) {
                        var positionIndex = (nextSpawnPositionIndex + i) % spawnPositions.length;
                        if (chosenPositions[positionIndex] === 0) {
                            chosenPositionIndex = positionIndex;
                            chosenPositions[positionIndex] = 1; // Mark the position as chosen
                            nextSpawnPositionIndex = (positionIndex + 1) % spawnPositions.length; // Update next spawn position index
                            break;
                        }
                    }

                    if (chosenPositionIndex === null) {
                        chosenPositions = Array(spawnPositions.length).fill(0);
                        nextSpawnPositionIndex = 0;
                        chosenPositionIndex = 0;
                    }


                    var chosenPosition = spawnPositions[chosenPositionIndex];

                    powerUp.position.copy(chosenPosition);
                    //powerUp.position.y=-90;
                    scene.add(powerUp);
                    powerUps.push(powerUp);
                    if (powerUps.length > 2) {
                        scene.remove(powerUps.shift());
                    }

                });
            }

            function collectPowerUp() {
                collectedPowerUps++; // Increment collected power-up count
                if(collectedPowerUps <= 3){
                    updatePowerUpBar(collectedPowerUps);
                }    
            }

            function updatePowerUpBar(collectedPowerUps) {
                var progressBar = document.getElementById('powerup-progress');
                var shieldText = document.getElementById('shield-text');
                var progressPercentage = (collectedPowerUps / 3) * 100; // Calculate the progress percentage
                progressBar.style.width = progressPercentage + '%'; // Update the progress bar's width

                if (collectedPowerUps >= 3) {
                    progressBar.style.backgroundColor = 'blue'; // Change the progress bar color
                    shieldText.style.display = 'block'; // Display the "Shield Available" text
                } else {
                    progressBar.style.backgroundColor = 'blue'; // Reset the progress bar color
                    shieldText.style.display = 'none'; // Hide the "Shield Available" text
                }
            }


            const moveLeft = () => {
                character.rotation.z = 0;
                if (character && character.position.x < 800) { // Adjust the character's movement range as needed
                    character.position.x += this.speed;
                    character.rotation.z -= 0.05; // Rotate the spaceship slightly to the left
                }
                
            };

            const moveRight = () => {
                character.rotation.z = 0;
                if (character && character.position.x > -900) { // Adjust the character's movement range as needed
                    character.position.x -= this.speed;
                    character.rotation.z += 0.05; // Rotate the spaceship slightly to the right
                }
            };

            function createShield() {
                var shieldGeometry = new THREE.SphereGeometry(150, 32, 32); // Define shield geometry
                var shieldMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff, transparent: true, opacity: 0.5 }); // Define shield material
                var shield = new THREE.Mesh(shieldGeometry, shieldMaterial); // Create shield mesh
                shield.position.copy(character.position); // Position the shield around the character
                scene.add(shield); // Add shield to the scene

                // Update shield's position continuously to match the character's position
                function updateShieldPosition() {
                    shield.position.copy(character.position);
                }

                // Call updateShieldPosition continuously
                function update() {
                    updateShieldPosition();
                    requestAnimationFrame(update);
                }
                update();

                setTimeout(function() {
                    activateShields= false;
                    scene.remove(shield); // Remove shield after some time (e.g., 5 seconds)
                }, 5000); // Adjust the duration of the shield as needed
            }

            function activateShield() {
                console.log("Invincibility shield activated!");
                updatePowerUpBar(0); // Reset power-up bar
                collectedPowerUps = 0; // Reset collected power-ups
                activateShields = true;
                clearTimeout(shotTimeout);
                createShield(); // Create the shield when activated
                // Increase character speed while shield is active
                this.speed = 100; // Increase speed by 50%
                setTimeout(deactivateShield, 5000); // Deactivate shield after 5 seconds
            }

            function deactivateShield() {
                console.log("Invincibility shield deactivated!");
                var shieldText = document.getElementById('shield-text');
                shieldText.style.display = 'none';
                this.speed /= 1.5; // Reset character speed to its original value
            }
            
            window.addEventListener('keydown', (event) => {
                if (gameStarted) {
                    if (event.key === 'ArrowLeft') {
                        moveLeft();
                    } else if (event.key === 'ArrowRight') {
                        moveRight();
                    } else if (event.key === ' ') { 
                        console.log('Space key pressed!');
                        if (collectedPowerUps >= 1) { 
                            activateShield();
                        }
                    }
                }
            });

            function createStars() {
                var stars = new Array(0);
                for (var i = 0; i < 10000; i++) {
                    let x = THREE.Math.randFloatSpread(2000);
                    let y = THREE.Math.randFloatSpread(2000);
                    let z = THREE.Math.randFloatSpread(2000);
                    stars.push(x, y, z);
                }
                var starsGeometry = new THREE.BufferGeometry();
                starsGeometry.setAttribute("position", new THREE.Float32BufferAttribute(stars, 3));
                var starsMaterial = new THREE.PointsMaterial({ color: 0x888888 });
                starField = new THREE.Points(starsGeometry, starsMaterial);
                scene.add(starField);
            }

            function onWindowResize() {
                var WIDTH = window.innerWidth,
                    HEIGHT = window.innerHeight;

                camera.aspect = aspectRatio;
                camera.updateProjectionMatrix();
                renderer.setSize(WIDTH, HEIGHT);
            }

            function selectRandomIndex(spawnPositions, chosenPositions) {
                let randomIndex = Math.floor(Math.random() * spawnPositions.length);

                // Check if the chosen position is already taken
                while (chosenPositions[randomIndex] !== 0) {
                    randomIndex = Math.floor(Math.random() * spawnPositions.length);
                }

                return randomIndex;
            }

            function loop() {
                starField.rotation.x += 0.001;
                starField.rotation.y += 0.001;
                chosenPositions = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
                if (alien) {
                    // Rotate the alien spaceship around its y-axis
                    alien.rotation.y += 0.01; // You can adjust the rotation speed as needed
                }

                if (astronaut) {
                    astronaut.position.x -= 10;
                    astronaut.position.z += 1;
                    astronaut.rotation.y += 0.0001;
                    if (astronaut.position.x < -4000) {
                        astronaut.position.x=3000
                        astronaut.position.z=500
                    }
                }
                 

                var currentTime = Date.now();
                if (currentTime - lastPowerUpSpawnTime >= powerUpSpawnInterval && powerUps.length === 0) {
                    createPowerUp(scene, powerUps);
                    lastPowerUpSpawnTime = currentTime; // Update last spawn time
                }

                if(currentTime - lastSpeedIncrease >= 10000){
                    obstacleSpeed += 5;
                    createObject(scene, obstacles);
                    lastSpeedIncrease = currentTime;
                }

                for (var i = 0; i < obstacles.length; i++) {
                    var obstacle = obstacles[i];
                    if (obstacle.position) {
                        obstacle.position.z -= obstacleSpeed;
                        if (obstacle.position.z < -1000) {
                            obstacle.position.z = 2000;

                            var index = selectRandomIndex(spawnPositions,chosenPositions)
                            chosenPositions[index] = 1

                            obstacle.position.x = spawnPositions[index].x
                        }
                        if (character) {
                            if (character.position.distanceTo(obstacle.position) < 50) {//change number here for hitbox of obstacles
                                if (obstacle.isPowerUp) {
                                    continue; // Example: Increase speed by 5 when power-up is collected    
                                } else {
                                    if(activateShields){
                                        continue;
                                    }
                                    else{
                                        endGame(); // Game ends if collided with an obstacle
                                    }
                                }
                                scene.remove(obstacle);
                                obstacles.splice(i, 1);
                            }
                        }
                    }
                }

                for (var j = 0; j < powerUps.length; j++) {
                    var powerUp = powerUps[j];
                    if (powerUp.position) {
                        powerUp.position.z -= 10;
                        if (powerUp.position.z < -1000) {
                            powerUp.position.z = 1050;
                            powerUp.position.x = Math.random() * 400 - 200;
                        }
                        if (character && character.position.distanceTo(powerUp.position) < 350) { //change number here for hitbox of powerups
                            collectPowerUp(); // Call function to handle power-up collection
                            console.log('Power-up collected!');
                            console.log('Power-ups collected: ' + collectedPowerUps);
                            scene.remove(powerUp);
                            powerUps.splice(j, 1);
                        }
                    }
                }

                if (gameStarted) {
                    var currentTime = Date.now();
                    var elapsedTime = Math.floor((currentTime - startTime) / 1000);
                    timerElement.textContent = 'Time: ' + elapsedTime + 's';
                }

                renderer.render(scene, camera);
                requestAnimationFrame(loop);
            }
            loop();
        }
    </script>
</body>
</html>
