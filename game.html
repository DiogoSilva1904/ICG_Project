<!DOCTYPE html>
<html>
<head>
    <title>Endless runner - Game Page</title>
    <meta content="width=device-width, initial-scale=1" name="viewport">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.130.1/examples/js/loaders/GLTFLoader.js"></script>
    <style>
        body {
            margin: 0;
        }
        #timer {
            position: absolute;
            top: 20px;
            left: 20px;
            font-family: Arial, sans-serif;
            font-size: 24px;
            color: white;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }
    </style>
</head>
<body class="body" style="overflow: hidden;">
    <div id="timer"></div>
    <script>
        var gameStarted = false;
        var startTime;
        var timerElement = document.getElementById('timer');
        var character; // Define character object globally
        var lastPowerUpSpawnTime = Date.now(); // Initialize last power-up spawn time
        var powerUpSpawnInterval = 10000;
        var powerUpCollected = false; // Flag to indicate whether the power-up is collected
        var shotTimeout;

        var Colors = {
            roadColor: 0x999999,
            obstacleColor: 0xff0000,
            characterColor: 0x00ff00,
            ballColor: 0x8B4513
        };

        window.addEventListener('load', function(){
            startGame();
        });

        function startGame() {
            gameStarted = true;
            startTime = Date.now();
            new World();
        }

        function endGame() {
            gameStarted = false;
            var currentTime = Date.now();
            var elapsedTime = Math.floor((currentTime - startTime) / 1000);
            sessionStorage.setItem('elapsedTime', elapsedTime); // Save elapsed time in sessionStorage
            window.location.href = 'end.html'; // Redirect to end.html to show the end page
        }

        function World() {
            'use strict';
            var scene, camera, renderer, road, obstacles = [], powerUps = [], shots = [];
            var container, aspectRatio,
                HEIGHT, WIDTH, fieldOfView,
                nearPlane, farPlane,
                mouseX, mouseY, windowHalfX,
                windowHalfY, geometry,
                starStuff, materialOptions,starField;

            this.speed = 10;    

            init();


            function init() {
                container = document.createElement('div');
                document.body.appendChild(container);
                document.body.style.overflow = 'hidden';

                HEIGHT = window.innerHeight;
                WIDTH = window.innerWidth;
                aspectRatio = WIDTH / HEIGHT;
                fieldOfView = 75;
                nearPlane = 1;
                farPlane = 1000;
                mouseX = 0;
                mouseY = 0;

                windowHalfX = WIDTH / 2;
                windowHalfY = HEIGHT / 2;

                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
                camera.position.set(0, 500, -1000);
                camera.lookAt(0, 50, 0);

                scene = new THREE.Scene();
                scene.fog = new THREE.FogExp2(0x000000, 0.0003);

                var ambientLight = new THREE.AmbientLight(0xffffff, 10);
                scene.add(ambientLight);

                character = null;

                var loader = new THREE.GLTFLoader();
                loader.load('nave_espacial/scene.gltf', function (gltf) {
                    character = gltf.scene;
                    character.scale.set(10, 10, 10);
                    character.position.x = Math.random() * 1000 - 200;
                    character.position.y = 100;
                    scene.add(character);
                });

                renderer = new THREE.WebGLRenderer();
                renderer.setClearColor(0x000011, 1);
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.setSize(WIDTH, HEIGHT);
                document.body.appendChild(renderer.domElement);

                createStars();

                const numObstacles = Math.floor(Math.random() * 5) + 1; // Random number between 1 and 5
                for (let i = 0; i < numObstacles; i++) {
                    createObject(scene, obstacles);
                }

                window.addEventListener('resize', onWindowResize, false);
                loop();
            }


            function createObject(scene, objectList) {
                var loader = new THREE.GLTFLoader();
                loader.load('asteroid/scene.gltf', function (gltf) {
                    var obstacle = gltf.scene;
                    obstacle.scale.set(100, 100, 100);
                    obstacle.position.x = Math.random() * 900 - 200;
                    obstacle.position.y = 25;
                    obstacle.position.z = 1000;
                    scene.add(obstacle);
                    obstacles.push(obstacle);
                    if (obstacles.length > 4) {
                        scene.remove(obstacles.shift());
                    }
                });
            }

            function createPowerUp(scene, powerUps) {
                var loader = new THREE.GLTFLoader();
                loader.load('gold_star/scene.gltf', function (gltf) {
                    var powerUp = gltf.scene;
                    powerUp.scale.set(5, 5, 5);
                    powerUp.position.x = Math.random() * 900 - 200;
                    powerUp.position.y = 25;
                    powerUp.position.z = 1000;
                    scene.add(powerUp);
                    powerUps.push(powerUp);
                    if (powerUps.length > 2) {
                        scene.remove(powerUps.shift());
                    }

                    // Set powerUpCollected to true when power-up is collected
                    powerUpCollected = true;

                    // Set a timeout to reset powerUpCollected after a certain duration
                    shotTimeout = setTimeout(function() {
                        powerUpCollected = false;
                    }, 5000); // Adjust the duration as needed (5000 milliseconds = 5 seconds)
                });
            }

            function createShot(scene, shots, position) {
                var loader = new THREE.GLTFLoader();
                loader.load('star_wars_shot/scene.gltf', function (gltf) {
                    var shot = gltf.scene;
                    shot.scale.set(2, 2, 2);
                    shot.position.copy(position);
                    scene.add(shot);
                    shots.push({ object: shot, velocity: new THREE.Vector3(0, 0, 20) });
                });
            }

            const moveLeft = () => {
                if (character && character.position.x < 900) {//mudar até onde a nave vai
                    character.position.x += this.speed;
                }
            };

            const moveRight = () => {
                if (character && character.position.x > -900) {//mudar até onde a nave vai
                    character.position.x -= this.speed;
                }
            };

            const jump = () => {
                if (character && character.position.y === 25) {
                    character.position.y += 300;
                    setTimeout(() => {
                        character.position.y -= 300;
                    }, 500);
                }
            };

            document.addEventListener('keydown', function (event) {
                if (gameStarted) {
                    if (event.key === 'ArrowLeft') {
                        moveLeft();
                    } else if (event.key === 'ArrowRight') {
                        moveRight();
                    } else if (event.key === 'ArrowUp') {
                        jump();
                    } else if (event.key === ' ' && powerUpCollected) { // Spacebar for shooting only when power-up is collected
                        if (character) {
                            createShot(scene, shots, character.position.clone());
                        }
                    }
                }   
            });

            function createStars(){
                var stars = new Array(0);
                for ( var i = 0; i < 10000; i ++ ) {
                    let x = THREE.Math.randFloatSpread( 2000 );
                    let y = THREE.Math.randFloatSpread( 2000 );
                    let z = THREE.Math.randFloatSpread( 2000 );
                    stars.push(x, y, z);
                }
                var starsGeometry = new THREE.BufferGeometry();
                starsGeometry.setAttribute(
                    "position", new THREE.Float32BufferAttribute(stars, 3)
                );
                var starsMaterial = new THREE.PointsMaterial( { color: 0x888888 } );
                starField = new THREE.Points( starsGeometry, starsMaterial );
                scene.add( starField );
            }

            function onWindowResize() {
                var WIDTH = window.innerWidth,
                    HEIGHT = window.innerHeight;

                camera.aspect = aspectRatio;
                camera.updateProjectionMatrix();
                renderer.setSize(WIDTH, HEIGHT);
            }

            function loop() {
                starField.rotation.x += 0.001;
                starField.rotation.y += 0.001;

                var currentTime = Date.now();
                if (currentTime - lastPowerUpSpawnTime >= powerUpSpawnInterval && powerUps.length === 0) {
                    createPowerUp(scene, powerUps);
                    lastPowerUpSpawnTime = currentTime; // Update last spawn time
                }

                for (var i = 0; i < obstacles.length; i++) {
                    var obstacle = obstacles[i];
                    if (obstacle.position) {
                        obstacle.position.z -= 10;
                        if (obstacle.position.z < -1000) {
                            obstacle.position.z = 1050;
                            obstacle.position.x = Math.random() * 400 - 200;
                        }
                        if (character) {
                            var obstacleHit = false; // Flag to indicate if the obstacle is hit by a shot
                            for (var k = 0; k < shots.length; k++) {
                                var shot = shots[k];
                                if (obstacle.position.distanceTo(shot.object.position) < 200) {
                                    scene.remove(shot.object);
                                    shots.splice(k, 1);
                                    scene.remove(obstacle);
                                    obstacles.splice(i, 1);
                                    obstacleHit = true;
                                    break; // Break out of the inner loop to avoid errors when modifying the array while iterating
                                }
                            }
                            if (!obstacleHit) {
                                if (character.position.distanceTo(obstacle.position) < 350) {
                                    if (obstacle.isPowerUp) {
                                        continue; // Example: Increase speed by 5 when power-up is collected    
                                    } else {
                                        endGame(); // Game ends if collided with an obstacle
                                    }
                                    scene.remove(obstacle);
                                    obstacles.splice(i, 1);
                                }
                            }
                        }
                    }
                }

                for (var j = 0; j < powerUps.length; j++) {
                    var powerUp = powerUps[j];
                    if (powerUp.position) {
                        powerUp.position.z -= 10;
                        if (powerUp.position.z < -1000) {
                            powerUp.position.z = 1050;
                            powerUp.position.x = Math.random() * 400 - 200;
                        }
                        if (character && character.position.distanceTo(powerUp.position) < 350) { 
                            // Define behavior of power-up, e.g., increase speed
                            // For example, you can add functionality here to increase the player's score or abilities
                            scene.remove(powerUp);
                            powerUps.splice(j, 1);
                        }
                    }
                }

                for (var k = 0; k < shots.length; k++) {
                    var shot = shots[k];
                    shot.object.position.add(shot.velocity);
                    if (shot.object.position.z < -1000) {
                        scene.remove(shot.object);
                        shots.splice(k, 1);
                    } else {
                        for (var m = 0; m < obstacles.length; m++) {
                            var obstacle = obstacles[m];
                            if (obstacle.position.distanceTo(shot.object.position) < 200) {
                                scene.remove(shot.object);
                                shots.splice(k, 1);
                                scene.remove(obstacle);
                                obstacles.splice(m, 1);
                                break; // Break out of the inner loop to avoid errors when modifying the array while iterating
                            }
                        }
                    }
                }

                if (gameStarted) {
                    var currentTime = Date.now();
                    var elapsedTime = Math.floor((currentTime - startTime) / 1000);
                    timerElement.textContent = 'Time: ' + elapsedTime + 's';
                }

                renderer.render(scene, camera);
                requestAnimationFrame(loop);
            }
            loop();
        };
    </script>
</body>
</html>
